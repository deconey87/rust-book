// コンスリスト
// これはコンパイルできない。コンパイルのためには、型のサイズの大きさがわからないといけないが、
// 再帰的な型はどのくらい大きくなるのか、コンパイラは判断できない
// enum List {
//     Cons(i32, List),
//     Nil,
// }

// Box<T>はポインタなので、データのサイズに左右されずに Box<T> に必要な領域が決まる
// だからコンパイルできる
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use List::{Cons, Nil};

fn main() {
    // スマートポインタ
    // ポインタのように振る舞うだけでなく、追加のメタデータと能力があるデータ構造

    // Bop<T>
    // ヒープにデータを確保し、スタックにはそのポインタを持つ
    let b = Box::new(5);
    // Boxは、データがスタックにあるのと同じような方法でアクセスできる
    println!("b = {}", b);

    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}
